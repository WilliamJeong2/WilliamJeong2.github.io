[
{
	"uri": "https://williamjeong2.github.io/blog/1-extract-google-account-profile-picture/",
	"title": "구글 프로필 사진 다운로드하기",
	"tags": [],
	"description": "",
	"content": "구글 프로필 사진을 다운받아야 할 경우가 가끔 있다. 한글로 검색해보니 정보가 나오지 않아서 검색 결과의 내용을 정리해 두고자 한다.\n여러개의 구글 계정을 사용중이라면 CTRL + SHIFT + N 을 눌러 private window 를 하나 만든다.\n  프로필 사진을 다운받고자 하는 계정으로 gmail같은 구글 서비스를 로그인 한다. https://get.google.com/albumarchive 에 접속한다. 프로필 사진 \u0026gt; Profile Photos 으로 이동한다. 여기에서 계정의 모든 프로필 사진들을 찾을 수 있다. 우측 상단 구석에 있는 triple dot 버튼을 사용해서 하나의 사진을 다운받거나 모든 사진을 다운받을 수 있다.  "
},
{
	"uri": "https://williamjeong2.github.io/about/",
	"title": "About",
	"tags": [],
	"description": "",
	"content": "Jinwoo Jeong 정진우 Contact  jinwoo5480@snu.ac.kr   Interests  Bioinformatics Data Scientist Deep Learning   Educations and Research Experiences Master Student of BiKE Lab in Seoul National University\nEditing\u0026hellip;\n Stacks \n"
},
{
	"uri": "https://williamjeong2.github.io/blog/2-how-to-save-apple-time-machine-mackups-to-cloud-services/",
	"title": "맥 타임머신을 클라우드 서비스에 하기(원드라이브, 구글드라이브, 드랍박스 등)",
	"tags": [],
	"description": "",
	"content": " *이 글은 Lhyam Sumal의 HOW TO SAVE APPLE TIME MACHINE BACKUPS TO CLOUD SERVICES LIKE ONEDRIVE 를 번역한 글입니다. 모든 저작권과 권리는 Sumal에게 있습니다.\n*This article is a translated version of Lhyam Sumal\u0026rsquo;s article: HOW TO SAVE APPLE TIME MACHINE BACKUPS TO CLOUD SERVICES LIKE ONEDRIVE. All rights goes back to him.\n*제가 이해한 대로 번역하였기 때문에 완벽하지 않을 수 있습니다.\n 타임머신은 굉장한 기능이면서, 제 생각에는 macOS의 최고 기능입니다. 네, 윈도우에도 파일 히스토리가 있지만 타임머신만큼 포괄적인 것은 없습니다. 말 그대로 맥을 복원하고 프로그램을 다시 설치하거나 환경설정을 지정하거나 driver를 사용하지 않고도 이전에 중단한 위치를 정확하게 선택할 수 있습니다!\n그러나 백업하려면 외장하드가 연결되어야 합니다. 물론 2018년(원문이 쓰인 날)에는 클라우드 서비스에 백업할 수 있습니다. 저는 마이크로소프트 오피스 365를 구독해서 1TB의 공간을 가지고 있습니다. 문서, 사진, 음악, 비디오 및 데스크탑 폴더가 이미 원드라이브에 백업되는 반면에 내 프로그램들과 설정들은 어떤가요?\n놀랍게도 애플은 클라우드 서비스를 사용한 백업 옵션을 타임머신에서 제공하지 않습니다. 하지만 우리는 답을 찾을 것이다. 늘 그랬듯이..(의역)\n하지만 그렇게 열심히 찾아보지 않아도 되었습니다. 이전에 타임머신 백업을 네트워크 드라이브에 저장하는 방법을 약간의 수정을 통해서 할 수 있는 방법을 기사로 썼습니다. 다음은 타임머신을 원드라이브, 구글드라이브, 아이클라우드 또는 원하는 클라우드 서비스에 저장할 수 있는 방법입니다.\n어떻게 작동하는가? 이 글의 목적상 원드라이브를 사용하고 있지만 다른 클라우드 서비스도 동일한 방식으로 작동합니다. 맥에서 이미 클라우드 동기화 서비스를 사용하고 있다고 가정하면 다음 단계를 따르는 것이 매우 간단하며 몇 분 정도 걸립니다.\n가상 드라이브를 생성하여 클라우드 서비스에 저장한 다음 맥에 마운트 해야 합니다. 타임머신 설정을 약간 조정하면 맥에서 가상 드라이브를 인식하고 자동으로 저장을 시작합니다.\nmacOS가 변경 사항을 가상 드라이브에 저장할 때마다 원드라이브 앱은 해당 변경사항을 클라우드에 다시 동기화합니다.\n가상 드라이브 생성 가상 드라이브의 장점은 전체 1TB를 가상 드라이브에 할당된 공간으로 지정하더라도 실제 차지하는 공간은 그 안에 포함된 파일의 크기만큼만 됩니다.\n클라우드 드라이브 폴더 내에 디스크 이미지를 저장해야 합니다. 맥에서 원드라이브 폴더를 찾고 디스크 이미지를 여기에 저장했습니다.\n 디스크 유틸리티를 엽니다. 간단하게 Spotlight나 Alfred를 이용해 검색할 수 있습니다.- 파일 메뉴에서 새로운 이미지(New Image) \u0026gt; 빈 이미지(Black Image)를 선택합니다. (단축키 cmd+n) 클라우드 폴더를 찾아서 가상 드라이브 이름을 설정합니다. (MacBookTM)- 가상드라이브의 최대 용량을 입력합니다. 저의 경우 200 GB를 입력했습니다.- 포맷을 Mac OS 확장 (저널링)로 선택합니다. 암호화는 사용해도 되고 안 해도 되는데 사용한다면 128-bit 를 선택합니다. 그러면 암호를 입력하는 창이 뜨는데 복구할 때 사용하기 때문에 잊어버리면 안 됩니다. 파티션을 단일 파티션으로 설정합니다. 마지막으로 이미지 포맷을 분할 번들 디스크 이미지(sparse bundle disk image)로 선택합니다. 디스크 이미지 사이즈를 체크합니다. - 저의 경우 이미지 포맷을 변경하니까 사이즈가 기본으로 변경되어 다시 수정하였습니다.  완료하였다면 디스크 유틸리티를 종료 할 수 있습니다.\n가상 드라이브 마운트 저의 경우 자동으로 가상 드라이브가 마운트 되고 MacBookTM이 나타났습니다.\n자동으로 마운트 되지 않을 경우 파인더를 열고 디스크 이미지를 저장한 위치로 이동하여 두 번 클릭하면 됩니다.\n가상 드라이브를 인식하도록 타임머신 구성 이 파트는 조금 까다로워 보이지만 실제로는 간단합니다.\n  터미널을 엽니다. (저와 다른 창이 떠도 괜찮습니다.)\n  아래의 명령어를 입력합니다. 여기서 {mounted-disk-image}는 마운트 된 디스크의 이름입니다.\nsudo tmutil setdestination /Volumes/{mounted-disk-image} #저는 MacBookTimeMachine으로 했으니까 위의 이미지 처럼 입력하였습니다.   Enter를 누르세요.\n  비밀번호를 입력하라고 나오면 입력하고 Enter를 누르세요.\n  입력이 완료되면 exit를 눌러 터미널을 종료합니다.\n  타임머신 설정 거의 다 끝났습니다. 👏\n시스템 환경설정에서 타임머신을 열면 새로 만든 드라이브가 자동으로 나타납니다.\n타임머신에서 OneDrive 폴더 제외 이 부분은 권장하는 파트입니다. 그렇지 않으면 클라우드 동기화 폴더 포함하여 타임머신이 백업한 다음에 클라우드 동기화를 진행합니다.\n폴더를 제외하려면\n 타임머신 환경설정에서 옵션을 클릭합니다. + 아이콘을 클릭하고 클라우드 폴더를 선택합니다. (예: Onedrive 또는 googledrive) 저장을 클릭합니다.  그리고 당신은.. 타임머신이 가상드라이브 백업을 시작하고 원드라이브에 해당 변경 사항을 동기화할 것입니다. 더는 외장하드를 검색하거나 네트워크 서버 연결을 기다릴 필요가 없습니다.\n백업을 다운받기 위해서 조금 고통스럽겠지만 저를 믿으세요!\n 📝코멘트 백업을 진행하다 보면 매우 느린 속도에 좌절하게 되지만 이 속도를 개선해 줄 방법이 있습니다. 아래의 링크를 참고해주세요.\n 맥에서 타임머신 백업 시간을 크게 줄여주는 마법 같은 명령어  "
},
{
	"uri": "https://williamjeong2.github.io/bioinformatics/",
	"title": "Bioinformatics",
	"tags": [],
	"description": "Bioinformatics",
	"content": "생물정보학에 관한 글을 올립니다.\n"
},
{
	"uri": "https://williamjeong2.github.io/blog/6-10-steps-to-become-a-data-scientist/",
	"title": "데이터 과학자(Data Scientist)가 되기 위한 10단계",
	"tags": [],
	"description": "",
	"content": "  이 포스팅은 이 글 에 있는 포스팅을 번역한 내용입니다. 오역이나 의역이 있을 수 있습니다. Original source of this posting os form this article If the original quthor requests deletion, it will be deleted immediately.    최고의 엔지니어라도 data scientist가 되는건 쉽지 않습니다. 그러나 누구에게나 어렵지는 않으며 미리 알아야 할 몇 가지가 있습니다. 이 기사에서는 이를 살펴보고 데이터과학에서 성공 하기위한 로드맵을 제공합니다.\n1. What you need to do  목표 시간 설정하라 코드를 작성하기 위해 알아야 할 지식/경험을 계획하라 훌륭한 조언을 해주는 똑똑한 사람에게 시간을 할애하라 흥미로운 데이터셋을 선택하고 검색해보아라 가장 큰 도전은 시작하는 것 이진 분류를 잊어라 : 교차 검증(cross-validation) 및 베이지안 알고리즘(Bayesian algorithms)은 훌륭한 데이터 과학자가 되는데 도움이 될 것임 데이터 과학 인터뷰에서 올바르게 질문하는 방법을 배워라  2. Problem Statement 모든 질문에 문제 서술을 영어로 작성합니다. 제가 이미 데이터 과학의 문제들을 읽을 수 있게 포스트로 작성해놨습니다.\n3. Write some code 코드를 작성하고 돌려보세요. 면접관은 코드를 보고 질문할 것입니다.\n 데이터 준비에 얼마나 시간이 걸리는지 문제를 해결하기 위해 팀에 몇명이 필요한지 무엇이 잘못 될 수 있나요? 이건 작업하기 쉬운 도구 3가지를 선택하는 힌트를 줍니다. 문제를 해결하는 데 사용할 도구를 작성하세요  4. Prepare and evaluate your answers 간결하면서 독창적인 해결방법이 있는지 확인합니다.\n5. Review your answers 답변을 수정하고 기존 framework나 tool을 사용하지 않는 이유를 스스로에게 물어봅니다.\n이러면 스스로 더 배울 필요가 있는 영역을 구분하고 향후 면접을 위해 자료를 작성하는데 도움이 됩니다.\n6. Show your solution to the problem 추가로, 해결방법을 준비해 제 3자인 면접 관련 조직에게 연락을취해 보여주고 도움을 받으면 좋습니다.\n당신의 해결방법을 노트북에 준비하고 팀과 해결방법에 대해 토의합니다.\n7. Identify Assumptions 면접관이 회사에 있다고 가정하고 해야할 일들을 정의하세요. 다른 사람들로부터 스스로 돋보이기 위해서는 이 가정은 생략/타협하면 안됩니다.\n8. Identify Solutions 팀이 예상한 것들과 해야할 일들을 확인해보세요. 시간이 있다면 이러한 것들을 검토해보는 것도 좋습니다.\n9. Use the Pareto Principle 통계의 개념 인 파레토 분포 법칙을 사용하세요. 이 경우 분포는 독립 이벤트 중 가장 좋은 결과를 제공할 가능성이 높습니다.\n10. Build a model 모든 질문에는 가지고 있는 데이터에 맞는 답이 있습니다. 강력한 해결방법을 정의하고 적용하는데 시간을 투자하여 향후 있을 면접에서 입증하세요.\n프로그래밍 경험은 데이터 과학에서 매우 중요합니다. 코드없이 코드를 실행하고 버그를 찾아야합니다. 이 경우 코드가 없는 것보다 더 나쁜 코드는 없습니다. 코드를 다시 작성하고 버그를 수정하라는 메시지가 보인다면 data scientist에게 문의하세요.\n프로그래밍 언어의 차이는 문화차이보다 중요하지 않습니다. 두 그룹의 learning curve가 당신이 좋은 기회를 갖기 위해 어디에 집중해야 하는지 고르는 데 도움이 될 겁니다.\n"
},
{
	"uri": "https://williamjeong2.github.io/blog/",
	"title": "Devlog",
	"tags": [],
	"description": "Devlog",
	"content": ""
},
{
	"uri": "https://williamjeong2.github.io/blog/7-docker-out-of-disk-space/",
	"title": "docker를 운영하다가 용량 부족 문제를 겪을 때.",
	"tags": [],
	"description": "",
	"content": "들어가면서 docker를 사용하다 보면 많은 이미지와 컨테이너를 다루게 됩니다. 따라서 docker 기본 경로에는 많은 용량이 누적되게 되고, 물리적인 용량 부족 문제를 겪게 됩니다. 용량 부족문제가 아니게 되더라도 사용하지 않는 이미지와 컨테이너를 삭제함으로 여유공간을 더욱 확보할 수 있게 됩니다. 이에 따라 해결방법을 알아보겠습니다.\n해결방법 해결 방법에는 몇 가지가 있습니다.\n1. 안쓰는 이미지, 컨테이너 삭제 컨테이너와 이미지를 rm 또는 rmi 명령어를 사용해서 지웠다고 하더라도 docker 경로의 용량변화는 없게 됩니다. 그럴 경우 아래의 명령어로 안쓰는 이미지와 컨테이너를 삭제 할 수 있습니다. 아래의 명령어에 대한 자세한 내용은 docker docs 를 참고해주세요.\ndocker system prune -a -f -a -f 옵션에 대한 설명입니다.\n -a - 컨테이너에 연결되지 않은 사용하지 않는 모든 이미지들 제거. -f - 프롬프트로 확인을 하지 않음.  2. docker 기본 경로 변경 💡 docker 기본 경로를 변경하면 기존 경로에 있던 이미지와 컨테이너들은 삭제됩니다. 미리 백업해두시길 바랍니다. docker가 이미지, 컨테이너를 저장하고 기타 파일을 저장하기 위해 사용하는 경로는 /var/lib/docker/ 입니다. 이 경로를 넉넉한 용량을 가진 디렉토리로 변경해주면 용량 문제를 벗어날 수 있겠죠?\n🙋🏻‍♂️ 아래의 방법은 도커 설정 파일을 통해 변경하는 방법입니다. /lib/systemd/system/docker.service 파일을 수정하는 방법도 있지만 아래의 방법을 권장합니다.\n daemon.json 파일을 만들어줍니다. 이 파일은 기본적으로 존재하지 않습니다. 따라서 아래의 경로에 만들어 주어야 합니다.\nvi /etc/docker/daemon.json 변경될 경로를 넣어줍니다. 이렇게 되면 도커가 실행할 때 저 파일을 읽어 path를 결정합니다.\n{ \u0026#34;graph\u0026#34;: \u0026#34;/home/path\u0026#34; # 원하는 경로로 설정 } json 파일을 저장하고 도커를 재시작합니다.\nsudo systemctl restart docker # systemctl 명령어가 사용되지 않을 경우 sudo service docker start 컨테이너를 실행하고 도커를 확인(ps -ef | grep docker)하면 아래처럼 변경된 경로로 나오는 것을 확인할 수 있습니다.\nroot 21800 19983 0 10:52 ? 00:00:00 docker-containerd-shim -namespace moby -workdir /home/ykkim/docker/containerd/daemon/io.containerd.runtime.v1.linux/moby/8adc00f3bbdd4fd44110f42a7b25e8598019963a83b6b8d3d29266c426701db8 -address /var/run/docker/containerd/docker-containerd.sock -containerd-binary /usr/bin/docker-containerd -runtime-root /var/run/docker/runtime-runc 이렇게 해서 docker 기본 경로를 변경하게 됩니다.\n"
},
{
	"uri": "https://williamjeong2.github.io/404.html",
	"title": "Whoops! Page not found",
	"tags": [],
	"description": "This is a 404 page",
	"content": "That page can\u0026rsquo;t be found.\nOur latest content is on the homepage.\nPhoto by Aron Visuals on Unsplash"
},
{
	"uri": "https://williamjeong2.github.io/blog/9-python-funtions/",
	"title": "보통 잘 모르는 파이썬 내장함수 3가지",
	"tags": [],
	"description": "",
	"content": "파이썬의 기본을 한 번 끝낸 후, 조금 더 심화된 파이썬 문법을 필요로 한다면 배워볼 수 있는 문법들입니다. 중급 문법들은 파이썬을 조금 더 쉽게 작성할 수 있도록 도와주고 불필요한 반복을 없애주죠. 이번 시간에는 map, filter, reduce에 대해 배워볼건데 이 3가지 함수들은 list를 다루는 함수입니다. 물론 기본 문법에서 배운 것처럼 이 3가지 함수를 사용하지 않아도 코딩하는 것에는 문제가 없습니다. 하지만 저의 경우에는 아래의 3가지 함수를 통해 반복문을 덜 사용하게 되었고, 불필요한 함수를 따로 만들어줄 필요가 없어서 편했습니다.\n자 그러면 시작해볼까요?\nmap map 은 리스트의 각 요소들을 지정된 함수로 처리하는 기능을 합니다. 쉽게 말하면 A라는 함수가 있고 list B가 있다면 A함수를 B로 수행한 결과를 돌려주는 거라고 할 수 있습니다.\n먼저 for 반복문을 사용하여 정수가 저장된 리스트를 제곱하고 2로 나누어 볼까요?\na = [1, 2, 3, 4] result = [] for i in range(len(a)): result.append(a[i] ** 2 / 2) print(result) 1, 2, 3, 4의 정수 리스트를 받아 제곱을 해주고 2로 나눠주는 코드입니다. 간단하죠? 실행 결과는 다음과 같습니다.\n 결과 : [0.5, 2.0, 4.5, 8.0]\n 이 예제를 map 함수를 사용해볼까요?\na = [1, 2, 3, 4] print(list(map(lambda x: x**2/2, a))) 똑같이 4개의 정수를 각 element를 받아 제곱을 해주고 2로 나눠주는 코드입니다. map 함수 앞에서 list 함수를 통해 list 자료형으로 변환하는 이유는 map 함수의 반환이 list가 아니기 때문인데요. Iterator 로 반환하는 값을 list로 변환하는 것입니다.(Iterator에 대해서는 다음에 따로 글을 써보겠습니다.)\nfilter 정의 : 무엇을 걸러내다.\n실제 filter 함수의 쓰임도 정의와 같습니다. filter 은 A라는 함수에 대해 리스트 B의 element 중 참에 해당하는 값을 돌려주는 것이라고 할 수 있습니다.\na = [-3, -2, -1, 0, 1, 2, 3] print(list(filter(lambda x: x\u0026gt;0, a))) -3에서 3까지의 정수중에서 0보다 큰 값을 돌려주는 코드입니다. 참 쉽죠?\n이 방법이 괜찮은데? 하지만 꼭 이 방법만을 써야하는건 아닙니다. 우리에게는 list comprehension 이 있습니다.\nmap 함수를 list comprehension으로 구현해 볼까요?\na = [1, 2, 3, 4] print([x**2/2 for x in a]) 오히려 더 간결한 것 같기도 하고..\nfilter 함수도 마찬가지입니다.\na = [-3, -2, -1, 0, 1, 2, 3] print([x for x in a if x\u0026gt;0]) 이처럼 방금 배운 map과 filter가 마음에 들지 않으면 list comprehensiond을\u0026hellip;쓸 수도 있습니다.\nreduce reduce 는 원래는 내장함수였는데 python 3부터 내장함수에서 빠지고 functools에서 가져와야 합니다.\nreduce에 대한 원리는 그림 한장으면 끝납니다.\n아이큐 테스트같지만 1부터 5까지 차례대로 더하는 거라는 걸 알 수 있겠죠? 수식으로 표현해 본다면 다음과 같습니다.\n((((1+2)+3)+4)+5) 코드로 작성해 보면 아래와 같습니다.\nfrom functools import reduce a = [1, 2, 3, 4, 5] print(reduce(lambda x, y: x+y, a)) reduce 함수의 경우에는 list comprehension로 대체할 수 없습니다. 이유는 reduce 함수는 2 element가 입력으로 들어가게 되는데 list comprehension은 2가지 입력을 받지 못하기 때문입니다.\n"
},
{
	"uri": "https://williamjeong2.github.io/blog/8-nas-network-drive-mount-on-ubuntu/",
	"title": "우분투에 NAS 마운트",
	"tags": [],
	"description": "",
	"content": "들어가면서 우리는 NAS를 사용하면서 데스크탑에 저장할 수 없는 대용량의 자료들을 저장하고는 합니다. 보통 백업의 용도로 사용되는데, 가끔은 외장하드처럼 마운트해서 사용해야 할 때가 있죠. 그래서 여러가지 접속 방법을 사용하여 자신의 PC에 있는 드라이브 처럼 사용할 수 있습니다. 윈도우는 검색하면 많이 나오는데 우분투의 경우에는 많이 없는 것 같아서 기록을 하게 되었습니다.\n환경 알아야 할 정보들:\n NAS IP NAS access ID NAS access PW 마운트할 nas 경로 마운트할 local 경로  Methods 1. 패키지 설치 마운트를 하기 위한 패키지 설치 단계로 cifs-utils를 설치해주어야 합니다.\nsudo apt-get install cifs-utils 2. 마운트 하기 위한 폴더 생성 NAS를 현재 우분투의 경로에 마운트를 해 주어야 하는데, 그러기 위해 폴더를 생성해줍니다.\nmkdir /mnt/nas-drive # /mnt/nas-drive 루트 경로에 추가하기 위해서는 sudo 권한이 필요할 것이며, # 자신의 디렉토리에 폴더를 생성해서 마운트도 가능합니다. 3. 네트워크 드라이브 연결 (마운트) 아래와 같은 형식으로 입력을 해주어야 합니다. 마지막에 위치하는 vers=1.0 을 입력해주어야 저는 에러가 나지 않더라구요.\nsudo mount -t cifs //{NAS drive IP}/{NAS directory path} {local path} -o user=\u0026#39;NAS ID\u0026#39;,password=\u0026#39;NAS PW\u0026#39;,rw,vers=1.0 예를 들어:\n NAS IP : 111.11.11.111 NAS access ID : admin NAS access PW : admin 마운트할 nas 경로 : /home 마운트할 local 경로 : /mnt/nas-drive  라는 환경이라면\nsudo mount -t cifs //111.11.11.111/home /mnt/nas-drive -o user=\u0026#39;admin\u0026#39;,password=\u0026#39;admin\u0026#39;,rw,vers=1.0 가 되겠죠?\n4. 자동 마운트 등록 4번을 진행하지 않는다면 재부팅 후에는 마운트가 끊어집니다. 계속 연결이 되어야 한다면 fstab 에 등록을 해주어서 부팅할 때마다 마운트 하도록 하면 됩니다.\nsudo vim /etc/fstab //111.11.11.111/home /mnt/nas-drive cifs user=\u0026#39;admin\u0026#39;,password=\u0026#39;admin\u0026#39;,rw,vers=1.0\t0\t0  "
},
{
	"uri": "https://williamjeong2.github.io/blog/4-weekly-archive-1/",
	"title": "🔖한 주간 본 영상, 글 아카이브 #1",
	"tags": [],
	"description": "",
	"content": "🗓 2019.12.02 ~ 2019.12.08\n 📃 포트스\n깃허브(GitHub)로 취업하기\n 개발자라면 다 하나씩은 가지고 있을만한 github 계정을 어떻게 관리해야 하는지, 커밋의 올바른 방법, readme.md 작성법, 오픈소스 기여하기 등을 다루고 있다. github 사용을 위해 약속한 사항들을 무시하고 사용하고 있었다는 생각이 들었다. 지금이라도 어느정도 (commit message rule과 같은) 정해진 틀을 갖추고 이용해야겠다.   "
},
{
	"uri": "https://williamjeong2.github.io/blog/5-weekly-archive-2/",
	"title": "🔖한 주간 본 영상, 글 아카이브 #2",
	"tags": [],
	"description": "",
	"content": "📄 포트스\n웹 서비스 출시 전 확인사항\n 웹 서비스를 개발하는 개발자는 아니지만 서비스 오픈 전 체크해야할 사항들에 대해서 이야기 하고 있다. 로그, 서버\u0026amp;리눅스, 데이터베이스 영역에서 놓칠 수 있는 설정들을 확인하고 대응할 수 있다.  나는 어떻게 공부했는가?\n \u0026lsquo;성장하는 개발자를 위한 팁\u0026rsquo;이라는 부제가 내 눈을 사로잡았다. 이 포스트는 성장하지 못하는 개발자들이 보다 효율적으로 성장할 수 있는 개발공부 가이드를 제공한다. 기억에 남는 부분이 마무리의 내용이었는데, 남들이 공부했던 방식을 그대로 따라가지 말고 자신에게 맞는 공부법을 찾으라는 말이었다. 개발자 뿐만 아니라 많은 사람들은 자기만의 패턴과 시간을 가지고 있다. 남들이 옳다고 하는 방법이 항상 옳지는 않기 때문에 자신의 방식을 찾을 필요가 있다는 말에 동감한다.   🗞️ 소식\n세계 최대 기업용 메신저 슬랙, 국내 상륙한다\n 사실 이미 쓸사람은 다 쓰고 있을거라고 생각하는데 국내 상륙한다고 해도 한글화와 고객지원 서비스정도라고 생각된다. MS사의 Teams이랑 경쟁을 어떤식으로 할 지 궁금하다. 사실 office365는 Teams을 기본으로 탑재하고 있기 때문에 비용 측면에서 유리한데 office와의 연동도 좋기 때문이다.   "
}]